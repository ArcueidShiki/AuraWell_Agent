#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MCPÂ∑•ÂÖ∑ÊÄßËÉΩÁõëÊéßÁ≥ªÁªü
Êèê‰æõËØ¶ÁªÜÁöÑÊÄßËÉΩÊåáÊ†áÊî∂ÈõÜ„ÄÅÂ≠òÂÇ®ÂíåÂëäË≠¶ÂäüËÉΩ
"""

import asyncio
import logging
import json
import time
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
from enum import Enum
import threading
from pathlib import Path

logger = logging.getLogger(__name__)


class AlertLevel(Enum):
    """ÂëäË≠¶Á∫ßÂà´"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


@dataclass
class PerformanceMetric:
    """ÊÄßËÉΩÊåáÊ†áÊï∞ÊçÆÁªìÊûÑ"""
    tool_name: str
    action: str
    execution_time: float
    success: bool
    timestamp: datetime
    mode_used: str
    error_message: Optional[str] = None
    parameters_hash: Optional[str] = None


@dataclass
class AlertRule:
    """ÂëäË≠¶ËßÑÂàô"""
    name: str
    condition: str  # Êù°‰ª∂Ë°®ËææÂºè
    threshold: float
    level: AlertLevel
    enabled: bool = True


class MCPPerformanceMonitor:
    """
    MCPÂ∑•ÂÖ∑ÊÄßËÉΩÁõëÊéßÂô®
    
    ÂäüËÉΩÔºö
    - ÂÆûÊó∂ÊÄßËÉΩÊåáÊ†áÊî∂ÈõÜ
    - ÂéÜÂè≤Êï∞ÊçÆÂ≠òÂÇ®
    - ÂëäË≠¶ËßÑÂàôÁÆ°ÁêÜ
    - ÊÄßËÉΩÊä•ÂëäÁîüÊàê
    """
    
    def __init__(self, db_path: str = "mcp_performance.db"):
        self.db_path = db_path
        self.metrics_buffer: List[PerformanceMetric] = []
        self.alert_rules: List[AlertRule] = []
        self.is_monitoring = False
        self.buffer_lock = threading.Lock()
        self._memory_conn = None  # Áî®‰∫éÂÜÖÂ≠òÊï∞ÊçÆÂ∫ìËøûÊé•

        # ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì
        self._init_database()

        # ËÆæÁΩÆÈªòËÆ§ÂëäË≠¶ËßÑÂàô
        self._setup_default_alert_rules()

        logger.info("üîç MCPÊÄßËÉΩÁõëÊéßÂô®ÂàùÂßãÂåñÂÆåÊàê")
    
    def _init_database(self):
        """ÂàùÂßãÂåñÊÄßËÉΩÊï∞ÊçÆÂ∫ì"""
        try:
            # Â¶ÇÊûúÊòØÂÜÖÂ≠òÊï∞ÊçÆÂ∫ìÔºåÁ°Æ‰øùËøûÊé•‰øùÊåÅÊ¥ªË∑É
            if self.db_path == ":memory:":
                self._memory_conn = sqlite3.connect(self.db_path, check_same_thread=False)
                conn = self._memory_conn
            else:
                conn = sqlite3.connect(self.db_path)

            cursor = conn.cursor()

            # ÂàõÂª∫ÊÄßËÉΩÊåáÊ†áË°®
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS performance_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    tool_name TEXT NOT NULL,
                    action TEXT NOT NULL,
                    execution_time REAL NOT NULL,
                    success BOOLEAN NOT NULL,
                    timestamp DATETIME NOT NULL,
                    mode_used TEXT NOT NULL,
                    error_message TEXT,
                    parameters_hash TEXT
                )
            """)

            # ÂàõÂª∫ÂëäË≠¶ËÆ∞ÂΩïË°®
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS alert_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    rule_name TEXT NOT NULL,
                    level TEXT NOT NULL,
                    message TEXT NOT NULL,
                    timestamp DATETIME NOT NULL,
                    resolved BOOLEAN DEFAULT FALSE
                )
            """)

            # ÂàõÂª∫Á¥¢Âºï
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_tool_timestamp ON performance_metrics(tool_name, timestamp)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_timestamp ON performance_metrics(timestamp)")

            conn.commit()

            # Âè™ÊúâÈùûÂÜÖÂ≠òÊï∞ÊçÆÂ∫ìÊâçÂÖ≥Èó≠ËøûÊé•
            if self.db_path != ":memory:":
                conn.close()

            logger.info("üìä ÊÄßËÉΩÁõëÊéßÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂÆåÊàê")

        except Exception as e:
            logger.error(f"‚ùå Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            raise
    
    def _setup_default_alert_rules(self):
        """ËÆæÁΩÆÈªòËÆ§ÂëäË≠¶ËßÑÂàô"""
        self.alert_rules = [
            AlertRule(
                name="È´òÂìçÂ∫îÊó∂Èó¥",
                condition="avg_execution_time > threshold",
                threshold=5.0,
                level=AlertLevel.WARNING
            ),
            AlertRule(
                name="‰ΩéÊàêÂäüÁéá",
                condition="success_rate < threshold",
                threshold=80.0,
                level=AlertLevel.ERROR
            ),
            AlertRule(
                name="Â∑•ÂÖ∑‰∏çÂèØÁî®",
                condition="success_rate < threshold",
                threshold=10.0,
                level=AlertLevel.CRITICAL
            ),
            AlertRule(
                name="È¢ëÁπÅÈîôËØØ",
                condition="error_rate > threshold",
                threshold=20.0,
                level=AlertLevel.WARNING
            )
        ]
    
    def record_metric(self, tool_name: str, action: str, execution_time: float, 
                     success: bool, mode_used: str, error_message: Optional[str] = None):
        """ËÆ∞ÂΩïÊÄßËÉΩÊåáÊ†á"""
        metric = PerformanceMetric(
            tool_name=tool_name,
            action=action,
            execution_time=execution_time,
            success=success,
            timestamp=datetime.now(),
            mode_used=mode_used,
            error_message=error_message
        )
        
        with self.buffer_lock:
            self.metrics_buffer.append(metric)
        
        # Â¶ÇÊûúÁºìÂÜ≤Âå∫Êª°‰∫ÜÔºåËß¶ÂèëÊâπÈáèÂÜôÂÖ•
        if len(self.metrics_buffer) >= 100:
            asyncio.create_task(self._flush_metrics())
    
    async def _flush_metrics(self):
        """ÊâπÈáèÂÜôÂÖ•ÊÄßËÉΩÊåáÊ†áÂà∞Êï∞ÊçÆÂ∫ì"""
        if not self.metrics_buffer:
            return
        
        with self.buffer_lock:
            metrics_to_write = self.metrics_buffer.copy()
            self.metrics_buffer.clear()
        
        try:
            # ‰ΩøÁî®Ê≠£Á°ÆÁöÑÊï∞ÊçÆÂ∫ìËøûÊé•
            if self.db_path == ":memory:" and self._memory_conn:
                conn = self._memory_conn
                should_close = False
            else:
                conn = sqlite3.connect(self.db_path)
                should_close = True

            cursor = conn.cursor()

            for metric in metrics_to_write:
                cursor.execute("""
                    INSERT INTO performance_metrics
                    (tool_name, action, execution_time, success, timestamp, mode_used, error_message)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (
                    metric.tool_name,
                    metric.action,
                    metric.execution_time,
                    metric.success,
                    metric.timestamp,
                    metric.mode_used,
                    metric.error_message
                ))

            conn.commit()

            if should_close:
                conn.close()

            logger.debug(f"üìù ÂÜôÂÖ• {len(metrics_to_write)} Êù°ÊÄßËÉΩÊåáÊ†á")

        except Exception as e:
            logger.error(f"‚ùå ÊÄßËÉΩÊåáÊ†áÂÜôÂÖ•Â§±Ë¥•: {e}")
    
    async def get_performance_summary(self, hours: int = 24) -> Dict[str, Any]:
        """Ëé∑ÂèñÊÄßËÉΩÊëòË¶Å"""
        try:
            # ‰ΩøÁî®Ê≠£Á°ÆÁöÑÊï∞ÊçÆÂ∫ìËøûÊé•
            if self.db_path == ":memory:" and self._memory_conn:
                conn = self._memory_conn
                should_close = False
            else:
                conn = sqlite3.connect(self.db_path)
                should_close = True

            cursor = conn.cursor()
            
            # ËÆ°ÁÆóÊó∂Èó¥ËåÉÂõ¥
            since_time = datetime.now() - timedelta(hours=hours)
            
            # ÊÄª‰ΩìÁªüËÆ°
            cursor.execute("""
                SELECT 
                    COUNT(*) as total_calls,
                    SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_calls,
                    AVG(execution_time) as avg_execution_time,
                    MAX(execution_time) as max_execution_time,
                    MIN(execution_time) as min_execution_time
                FROM performance_metrics 
                WHERE timestamp > ?
            """, (since_time,))
            
            overall_stats = cursor.fetchone()
            
            # ÊåâÂ∑•ÂÖ∑ÁªüËÆ°
            cursor.execute("""
                SELECT 
                    tool_name,
                    COUNT(*) as calls,
                    SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successes,
                    AVG(execution_time) as avg_time,
                    COUNT(CASE WHEN success = 0 THEN 1 END) as failures
                FROM performance_metrics 
                WHERE timestamp > ?
                GROUP BY tool_name
                ORDER BY calls DESC
            """, (since_time,))
            
            tool_stats = cursor.fetchall()

            if should_close:
                conn.close()
            
            # ÊûÑÂª∫ÊëòË¶Å
            summary = {
                "time_range_hours": hours,
                "overall": {
                    "total_calls": overall_stats[0] or 0,
                    "successful_calls": overall_stats[1] or 0,
                    "success_rate": (overall_stats[1] / max(overall_stats[0], 1)) * 100 if overall_stats[0] else 0,
                    "avg_execution_time": round(overall_stats[2] or 0, 3),
                    "max_execution_time": round(overall_stats[3] or 0, 3),
                    "min_execution_time": round(overall_stats[4] or 0, 3)
                },
                "by_tool": []
            }
            
            for tool_stat in tool_stats:
                tool_name, calls, successes, avg_time, failures = tool_stat
                summary["by_tool"].append({
                    "tool_name": tool_name,
                    "calls": calls,
                    "successes": successes,
                    "success_rate": round((successes / calls) * 100, 2),
                    "avg_execution_time": round(avg_time, 3),
                    "failures": failures
                })
            
            return summary
            
        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÊÄßËÉΩÊëòË¶ÅÂ§±Ë¥•: {e}")
            return {"error": str(e)}
    
    async def check_alerts(self) -> List[Dict[str, Any]]:
        """Ê£ÄÊü•ÂëäË≠¶Êù°‰ª∂"""
        alerts = []
        
        try:
            summary = await self.get_performance_summary(hours=1)  # Ê£ÄÊü•ÊúÄËøë1Â∞èÊó∂
            overall = summary.get("overall", {})
            
            for rule in self.alert_rules:
                if not rule.enabled:
                    continue
                
                triggered = False
                message = ""
                
                if rule.name == "È´òÂìçÂ∫îÊó∂Èó¥":
                    avg_time = overall.get("avg_execution_time", 0)
                    if avg_time > rule.threshold:
                        triggered = True
                        message = f"Âπ≥ÂùáÂìçÂ∫îÊó∂Èó¥ {avg_time:.2f}s Ë∂ÖËøáÈòàÂÄº {rule.threshold}s"
                
                elif rule.name == "‰ΩéÊàêÂäüÁéá":
                    success_rate = overall.get("success_rate", 100)
                    if success_rate < rule.threshold:
                        triggered = True
                        message = f"ÊàêÂäüÁéá {success_rate:.1f}% ‰Ωé‰∫éÈòàÂÄº {rule.threshold}%"
                
                elif rule.name == "Â∑•ÂÖ∑‰∏çÂèØÁî®":
                    success_rate = overall.get("success_rate", 100)
                    if success_rate < rule.threshold:
                        triggered = True
                        message = f"Â∑•ÂÖ∑Âá†‰πé‰∏çÂèØÁî®ÔºåÊàêÂäüÁéá‰ªÖ {success_rate:.1f}%"
                
                if triggered:
                    alert = {
                        "rule_name": rule.name,
                        "level": rule.level.value,
                        "message": message,
                        "timestamp": datetime.now().isoformat(),
                        "threshold": rule.threshold
                    }
                    alerts.append(alert)
                    
                    # ËÆ∞ÂΩïÂëäË≠¶ÂéÜÂè≤
                    await self._record_alert(alert)
            
        except Exception as e:
            logger.error(f"‚ùå ÂëäË≠¶Ê£ÄÊü•Â§±Ë¥•: {e}")
        
        return alerts
    
    async def _record_alert(self, alert: Dict[str, Any]):
        """ËÆ∞ÂΩïÂëäË≠¶ÂéÜÂè≤"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT INTO alert_history (rule_name, level, message, timestamp)
                VALUES (?, ?, ?, ?)
            """, (
                alert["rule_name"],
                alert["level"],
                alert["message"],
                datetime.now()
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"‚ùå ÂëäË≠¶ËÆ∞ÂΩïÂ§±Ë¥•: {e}")
    
    async def start_monitoring(self, check_interval: int = 300):
        """ÂêØÂä®ÁõëÊéßÔºàÊØè5ÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°Ôºâ"""
        self.is_monitoring = True
        logger.info("üöÄ ÂêØÂä®MCPÊÄßËÉΩÁõëÊéß")
        
        while self.is_monitoring:
            try:
                # Âà∑Êñ∞ÁºìÂÜ≤Âå∫
                await self._flush_metrics()
                
                # Ê£ÄÊü•ÂëäË≠¶
                alerts = await self.check_alerts()
                if alerts:
                    logger.warning(f"‚ö†Ô∏è Ê£ÄÊµãÂà∞ {len(alerts)} ‰∏™ÂëäË≠¶")
                    for alert in alerts:
                        logger.warning(f"üö® {alert['level'].upper()}: {alert['message']}")
                
                await asyncio.sleep(check_interval)
                
            except Exception as e:
                logger.error(f"‚ùå ÁõëÊéßÂæ™ÁéØÈîôËØØ: {e}")
                await asyncio.sleep(60)  # ÈîôËØØÊó∂Á≠âÂæÖ1ÂàÜÈíü
    
    def stop_monitoring(self):
        """ÂÅúÊ≠¢ÁõëÊéß"""
        self.is_monitoring = False
        logger.info("üõë ÂÅúÊ≠¢MCPÊÄßËÉΩÁõëÊéß")
    
    async def cleanup(self):
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        self.stop_monitoring()
        await self._flush_metrics()  # ÊúÄÂêé‰∏ÄÊ¨°Âà∑Êñ∞
        logger.info("üßπ MCPÊÄßËÉΩÁõëÊéßÊ∏ÖÁêÜÂÆåÊàê")


# ÂÖ®Â±ÄÁõëÊéßÂô®ÂÆû‰æã
_performance_monitor = None


def get_performance_monitor() -> MCPPerformanceMonitor:
    """Ëé∑ÂèñÂÖ®Â±ÄÊÄßËÉΩÁõëÊéßÂô®ÂÆû‰æã"""
    global _performance_monitor
    if _performance_monitor is None:
        _performance_monitor = MCPPerformanceMonitor()
    return _performance_monitor
